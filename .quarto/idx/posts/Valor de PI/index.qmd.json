{"title":"Estimando el valor de Pi: El azar a nuestro favor","markdown":{"yaml":{"title":"Estimando el valor de Pi: El azar a nuestro favor","author":"Mauricio Leon","date":"2026-01-20","categories":["matemáticas","python","simulación"],"image":"preview.jpg","execute":{"echo":true,"warning":false}},"headingText":"El valor de PI","containsRefs":false,"markdown":"\n\n\nTodos sabemos que el valor de $\\pi$ es aproximadamente $3.1415...$ y tal vez la \"demostración\" nos la enseñaron en la secundaria o preparatoria. Pero ¿y si lo vemos de otra manera? A continuación veremos otra forma de obtener el valor de $\\pi$ pero con una herramienta muy poderosa llamada **Simulación de Montecarlo**.\n\n### ¿Qué es la Simulación de Montecarlo?\n\nLa simulación de Montecarlo es un tipo de algoritmo computacional que utiliza un muestreo aleatorio repetido para obtener la probabilidad de que ocurra una serie de resultados. \n\nFue inventado por **John von Neumann** y **Stanislaw Ulam** durante la Segunda Guerra Mundial. Debe su nombre al famoso casino de Mónaco, ya que el elemento de azar es fundamental en el planteamiento del modelo, similar a un juego de ruleta. A diferencia de un modelo de pronóstico normal, esta simulación construye un modelo de posibles resultados aprovechando una distribución de probabilidad para cualquier variable que tenga incertidumbre inherente.\n\n### Aplicación para hallar el valor de PI\n\nSabemos por las fórmulas que nos enseñaron en la primaria que las áreas del cuadrado y del círculo se calculan como sigue:\n\n$$\\text{Área del círculo} = \\pi \\cdot r^2$$\n$$\\text{Área del cuadrado} = l^2$$\n\nSi inscribimos un círculo de radio $r=1$ dentro de un cuadrado de lado $l=2$, la relación de sus áreas es:\n\n$$\\frac{\\text{Área del Círculo}}{\\text{Área del Cuadrado}} = \\frac{\\pi \\cdot 1^2}{2^2} = \\frac{\\pi}{4}$$\n\nPor lo tanto, si lanzamos miles de puntos aleatorios al cuadrado, la proporción que caiga dentro del círculo multiplicada por 4 nos dará el valor de $\\pi$.\n\n### Implementación en Python\n\nHaremos uso de `numpy` y `matplotlib` para mostrar gráficamente lo que sucede.\n\n```{python}\n#| label: fig-montecarlo\n#| fig-cap: \"Simulación de Montecarlo: Puntos verdes dentro del círculo vs rojos fuera.\"\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Configuración de la simulación\ndef ejecutar_simulacion(n):\n    # 1. Generar n puntos aleatorios en un espacio 2D (x, y) entre -1 y 1\n    puntos = np.random.uniform(-1, 1, (n, 2))\n    \n    # 2. Calcular la distancia al origen (x^2 + y^2)\n    distancias = np.sum(puntos**2, axis=1)\n    \n    # 3. Identificar puntos dentro del círculo (distancia <= 1)\n    dentro_mask = distancias <= 1\n    puntos_dentro = np.sum(dentro_mask)\n    \n    # 4. Estimar Pi\n    pi_estimado = 4 * puntos_dentro / n\n    return puntos, dentro_mask, pi_estimado\n\n# Ejecución\nn_puntos = 10000\npuntos, mascara, resultado = ejecutar_simulacion(n_puntos)\n\n# Graficar resultados\nplt.figure(figsize=(8, 8))\nplt.scatter(puntos[mascara, 0], puntos[mascara, 1], color='#2ecc71', s=1, label='Dentro')\nplt.scatter(puntos[~mascara, 0], puntos[~mascara, 1], color='#e74c3c', s=1, label='Fuera')\n\n# Dibujar el círculo teórico para referencia\ncirculo = plt.Circle((0, 0), 1, color='black', fill=False, linewidth=2)\nplt.gca().add_artist(circulo)\n\nplt.title(f\"Estimación de $\\pi$ con {n_puntos} puntos: {resultado:.4f}\")\nplt.axis('equal')\nplt.legend()\nplt.show()\n```\n\n### Explicación de los resultados\n\nEl algoritmo funciona porque estamos simulando un experimento físico de manera digital. Al calcular np.sum(puntos**2, axis=1), estamos aplicando el teorema de Pitágoras para saber qué tan lejos está cada punto del centro $(0,0)$. Si la distancia es menor o igual a 1, el punto \"golpeó\" el círculo. A medida que aumentas el valor de $n$ en el código, notarás que el valor estimado se acerca cada vez más al valor real de $3.14159...$\n\n### Conclusión\n\nLa simulación de Montecarlo nos enseña que el azar, cuando se repite masivamente, revela patrones matemáticos exactos. Esta técnica no solo sirve para calcular $\\pi$, sino que es fundamental hoy en día en física nuclear, finanzas y ciencia de datos.","srcMarkdownNoYaml":"\n\n## El valor de PI\n\nTodos sabemos que el valor de $\\pi$ es aproximadamente $3.1415...$ y tal vez la \"demostración\" nos la enseñaron en la secundaria o preparatoria. Pero ¿y si lo vemos de otra manera? A continuación veremos otra forma de obtener el valor de $\\pi$ pero con una herramienta muy poderosa llamada **Simulación de Montecarlo**.\n\n### ¿Qué es la Simulación de Montecarlo?\n\nLa simulación de Montecarlo es un tipo de algoritmo computacional que utiliza un muestreo aleatorio repetido para obtener la probabilidad de que ocurra una serie de resultados. \n\nFue inventado por **John von Neumann** y **Stanislaw Ulam** durante la Segunda Guerra Mundial. Debe su nombre al famoso casino de Mónaco, ya que el elemento de azar es fundamental en el planteamiento del modelo, similar a un juego de ruleta. A diferencia de un modelo de pronóstico normal, esta simulación construye un modelo de posibles resultados aprovechando una distribución de probabilidad para cualquier variable que tenga incertidumbre inherente.\n\n### Aplicación para hallar el valor de PI\n\nSabemos por las fórmulas que nos enseñaron en la primaria que las áreas del cuadrado y del círculo se calculan como sigue:\n\n$$\\text{Área del círculo} = \\pi \\cdot r^2$$\n$$\\text{Área del cuadrado} = l^2$$\n\nSi inscribimos un círculo de radio $r=1$ dentro de un cuadrado de lado $l=2$, la relación de sus áreas es:\n\n$$\\frac{\\text{Área del Círculo}}{\\text{Área del Cuadrado}} = \\frac{\\pi \\cdot 1^2}{2^2} = \\frac{\\pi}{4}$$\n\nPor lo tanto, si lanzamos miles de puntos aleatorios al cuadrado, la proporción que caiga dentro del círculo multiplicada por 4 nos dará el valor de $\\pi$.\n\n### Implementación en Python\n\nHaremos uso de `numpy` y `matplotlib` para mostrar gráficamente lo que sucede.\n\n```{python}\n#| label: fig-montecarlo\n#| fig-cap: \"Simulación de Montecarlo: Puntos verdes dentro del círculo vs rojos fuera.\"\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Configuración de la simulación\ndef ejecutar_simulacion(n):\n    # 1. Generar n puntos aleatorios en un espacio 2D (x, y) entre -1 y 1\n    puntos = np.random.uniform(-1, 1, (n, 2))\n    \n    # 2. Calcular la distancia al origen (x^2 + y^2)\n    distancias = np.sum(puntos**2, axis=1)\n    \n    # 3. Identificar puntos dentro del círculo (distancia <= 1)\n    dentro_mask = distancias <= 1\n    puntos_dentro = np.sum(dentro_mask)\n    \n    # 4. Estimar Pi\n    pi_estimado = 4 * puntos_dentro / n\n    return puntos, dentro_mask, pi_estimado\n\n# Ejecución\nn_puntos = 10000\npuntos, mascara, resultado = ejecutar_simulacion(n_puntos)\n\n# Graficar resultados\nplt.figure(figsize=(8, 8))\nplt.scatter(puntos[mascara, 0], puntos[mascara, 1], color='#2ecc71', s=1, label='Dentro')\nplt.scatter(puntos[~mascara, 0], puntos[~mascara, 1], color='#e74c3c', s=1, label='Fuera')\n\n# Dibujar el círculo teórico para referencia\ncirculo = plt.Circle((0, 0), 1, color='black', fill=False, linewidth=2)\nplt.gca().add_artist(circulo)\n\nplt.title(f\"Estimación de $\\pi$ con {n_puntos} puntos: {resultado:.4f}\")\nplt.axis('equal')\nplt.legend()\nplt.show()\n```\n\n### Explicación de los resultados\n\nEl algoritmo funciona porque estamos simulando un experimento físico de manera digital. Al calcular np.sum(puntos**2, axis=1), estamos aplicando el teorema de Pitágoras para saber qué tan lejos está cada punto del centro $(0,0)$. Si la distancia es menor o igual a 1, el punto \"golpeó\" el círculo. A medida que aumentas el valor de $n$ en el código, notarás que el valor estimado se acerca cada vez más al valor real de $3.14159...$\n\n### Conclusión\n\nLa simulación de Montecarlo nos enseña que el azar, cuando se repite masivamente, revela patrones matemáticos exactos. Esta técnica no solo sirve para calcular $\\pi$, sino que es fundamental hoy en día en física nuclear, finanzas y ciencia de datos."},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":true,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.27","theme":{"light":"sandstone","dark":"solar"},"toc-title":"Contenido","code-copy":true,"code-summary":"Ver código","title-block-banner":true,"title":"Estimando el valor de Pi: El azar a nuestro favor","author":"Mauricio Leon","date":"2026-01-20","categories":["matemáticas","python","simulación"],"image":"preview.jpg"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}