[
  {
    "objectID": "posts/Valor de PI/index.html",
    "href": "posts/Valor de PI/index.html",
    "title": "Estimando el valor de Pi",
    "section": "",
    "text": "Todos sabemos que el valor de \\(\\pi\\) es aproximadamente \\(3.1415...\\) y tal vez la “demostración” nos la enseñaron en la secundaria o preparatoria. Pero ¿y si lo vemos de otra manera? A continuación veremos otra forma de obtener el valor de \\(\\pi\\) pero con una herramienta muy poderosa llamada Simulación de Montecarlo.\n\n\nLa simulación de Montecarlo es un tipo de algoritmo computacional que utiliza un muestreo aleatorio repetido para obtener la probabilidad de que ocurra una serie de resultados.\nFue inventado por John von Neumann y Stanislaw Ulam durante la Segunda Guerra Mundial. Debe su nombre al famoso casino de Mónaco, ya que el elemento de azar es fundamental en el planteamiento del modelo, similar a un juego de ruleta. A diferencia de un modelo de pronóstico normal, esta simulación construye un modelo de posibles resultados aprovechando una distribución de probabilidad para cualquier variable que tenga incertidumbre inherente.\n\n\n\nSabemos por las fórmulas que nos enseñaron en la primaria que las áreas del cuadrado y del círculo se calculan como sigue:\n\\[\\text{Área del círculo} = \\pi \\cdot r^2\\] \\[\\text{Área del cuadrado} = l^2\\]\nSi inscribimos un círculo de radio \\(r=1\\) dentro de un cuadrado de lado \\(l=2\\), la relación de sus áreas es:\n\\[\\frac{\\text{Área del Círculo}}{\\text{Área del Cuadrado}} = \\frac{\\pi \\cdot 1^2}{2^2} = \\frac{\\pi}{4}\\]\nPor lo tanto, si lanzamos miles de puntos aleatorios al cuadrado, la proporción que caiga dentro del círculo multiplicada por 4 nos dará el valor de \\(\\pi\\).\n\n\n\nHaremos uso de numpy y matplotlib para mostrar gráficamente lo que sucede.\n\n\nVer código\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Configuración de la simulación\ndef ejecutar_simulacion(n):\n    # 1. Generar n puntos aleatorios en un espacio 2D (x, y) entre -1 y 1\n    puntos = np.random.uniform(-1, 1, (n, 2))\n    \n    # 2. Calcular la distancia al origen (x^2 + y^2)\n    distancias = np.sum(puntos**2, axis=1)\n    \n    # 3. Identificar puntos dentro del círculo (distancia &lt;= 1)\n    dentro_mask = distancias &lt;= 1\n    puntos_dentro = np.sum(dentro_mask)\n    \n    # 4. Estimar Pi\n    pi_estimado = 4 * puntos_dentro / n\n    return puntos, dentro_mask, pi_estimado\n\n# Ejecución\nn_puntos = 10000\npuntos, mascara, resultado = ejecutar_simulacion(n_puntos)\n\n# Graficar resultados\nplt.figure(figsize=(8, 8))\nplt.scatter(puntos[mascara, 0], puntos[mascara, 1], color='#2ecc71', s=1, label='Dentro')\nplt.scatter(puntos[~mascara, 0], puntos[~mascara, 1], color='#e74c3c', s=1, label='Fuera')\n\n# Dibujar el círculo teórico para referencia\ncirculo = plt.Circle((0, 0), 1, color='black', fill=False, linewidth=2)\nplt.gca().add_artist(circulo)\n\nplt.title(f\"Estimación de $\\pi$ con {n_puntos} puntos: {resultado:.4f}\")\nplt.axis('equal')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1: Simulación de Montecarlo: Puntos verdes dentro del círculo vs rojos fuera.\n\n\n\n\n\n\n\n\nEl algoritmo funciona porque estamos simulando un experimento físico de manera digital. Al calcular np.sum(puntos**2, axis=1), estamos aplicando el teorema de Pitágoras para saber qué tan lejos está cada punto del centro \\((0,0)\\). Si la distancia es menor o igual a 1, el punto “golpeó” el círculo. A medida que aumentas el valor de \\(n\\) en el código, notarás que el valor estimado se acerca cada vez más al valor real de \\(3.14159...\\)\n\n\n\nLa simulación de Montecarlo nos enseña que el azar, cuando se repite masivamente, revela patrones matemáticos exactos. Esta técnica no solo sirve para calcular \\(\\pi\\), sino que es fundamental hoy en día en física nuclear, finanzas y ciencia de datos."
  },
  {
    "objectID": "posts/Valor de PI/index.html#el-valor-de-pi",
    "href": "posts/Valor de PI/index.html#el-valor-de-pi",
    "title": "Estimando el valor de Pi",
    "section": "",
    "text": "Todos sabemos que el valor de \\(\\pi\\) es aproximadamente \\(3.1415...\\) y tal vez la “demostración” nos la enseñaron en la secundaria o preparatoria. Pero ¿y si lo vemos de otra manera? A continuación veremos otra forma de obtener el valor de \\(\\pi\\) pero con una herramienta muy poderosa llamada Simulación de Montecarlo.\n\n\nLa simulación de Montecarlo es un tipo de algoritmo computacional que utiliza un muestreo aleatorio repetido para obtener la probabilidad de que ocurra una serie de resultados.\nFue inventado por John von Neumann y Stanislaw Ulam durante la Segunda Guerra Mundial. Debe su nombre al famoso casino de Mónaco, ya que el elemento de azar es fundamental en el planteamiento del modelo, similar a un juego de ruleta. A diferencia de un modelo de pronóstico normal, esta simulación construye un modelo de posibles resultados aprovechando una distribución de probabilidad para cualquier variable que tenga incertidumbre inherente.\n\n\n\nSabemos por las fórmulas que nos enseñaron en la primaria que las áreas del cuadrado y del círculo se calculan como sigue:\n\\[\\text{Área del círculo} = \\pi \\cdot r^2\\] \\[\\text{Área del cuadrado} = l^2\\]\nSi inscribimos un círculo de radio \\(r=1\\) dentro de un cuadrado de lado \\(l=2\\), la relación de sus áreas es:\n\\[\\frac{\\text{Área del Círculo}}{\\text{Área del Cuadrado}} = \\frac{\\pi \\cdot 1^2}{2^2} = \\frac{\\pi}{4}\\]\nPor lo tanto, si lanzamos miles de puntos aleatorios al cuadrado, la proporción que caiga dentro del círculo multiplicada por 4 nos dará el valor de \\(\\pi\\).\n\n\n\nHaremos uso de numpy y matplotlib para mostrar gráficamente lo que sucede.\n\n\nVer código\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Configuración de la simulación\ndef ejecutar_simulacion(n):\n    # 1. Generar n puntos aleatorios en un espacio 2D (x, y) entre -1 y 1\n    puntos = np.random.uniform(-1, 1, (n, 2))\n    \n    # 2. Calcular la distancia al origen (x^2 + y^2)\n    distancias = np.sum(puntos**2, axis=1)\n    \n    # 3. Identificar puntos dentro del círculo (distancia &lt;= 1)\n    dentro_mask = distancias &lt;= 1\n    puntos_dentro = np.sum(dentro_mask)\n    \n    # 4. Estimar Pi\n    pi_estimado = 4 * puntos_dentro / n\n    return puntos, dentro_mask, pi_estimado\n\n# Ejecución\nn_puntos = 10000\npuntos, mascara, resultado = ejecutar_simulacion(n_puntos)\n\n# Graficar resultados\nplt.figure(figsize=(8, 8))\nplt.scatter(puntos[mascara, 0], puntos[mascara, 1], color='#2ecc71', s=1, label='Dentro')\nplt.scatter(puntos[~mascara, 0], puntos[~mascara, 1], color='#e74c3c', s=1, label='Fuera')\n\n# Dibujar el círculo teórico para referencia\ncirculo = plt.Circle((0, 0), 1, color='black', fill=False, linewidth=2)\nplt.gca().add_artist(circulo)\n\nplt.title(f\"Estimación de $\\pi$ con {n_puntos} puntos: {resultado:.4f}\")\nplt.axis('equal')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1: Simulación de Montecarlo: Puntos verdes dentro del círculo vs rojos fuera.\n\n\n\n\n\n\n\n\nEl algoritmo funciona porque estamos simulando un experimento físico de manera digital. Al calcular np.sum(puntos**2, axis=1), estamos aplicando el teorema de Pitágoras para saber qué tan lejos está cada punto del centro \\((0,0)\\). Si la distancia es menor o igual a 1, el punto “golpeó” el círculo. A medida que aumentas el valor de \\(n\\) en el código, notarás que el valor estimado se acerca cada vez más al valor real de \\(3.14159...\\)\n\n\n\nLa simulación de Montecarlo nos enseña que el azar, cuando se repite masivamente, revela patrones matemáticos exactos. Esta técnica no solo sirve para calcular \\(\\pi\\), sino que es fundamental hoy en día en física nuclear, finanzas y ciencia de datos."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog:\nEste blog fue creado como un proyecto de pasatiempo en donde se busca mostrar algunas de las cosas aprendidas durante la carrera de Ingenieria Matematica, asi como las habilidades adquiridas posteriormente a la misma carrera.\n\n\nAbout me:\nMi nombre es Mauricio Leon, soy graduado de la Ingenieria en Matematicas de la Escuela Superior de Fisica y Matematicas (ESFM) del Insituto Politecnico Nacional (IPN). Me gusta estar aprendiendo constantemente y probarme a mi mismo con nuevos retos"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "MaviBlog",
    "section": "",
    "text": "Estimando el valor de Pi\n\n\n\nmatemáticas\n\npython\n\nsimulación\n\n\n\n\n\n\n\n\n\nJan 20, 2026\n\n\nMauricio Leon\n\n\n\n\n\nNo matching items"
  }
]